#X3D V3.3 utf8 Titania V3.0.4

PROFILE Full

META "comment" "World of Titania"

EXTERNPROTO Grid [
  inputOutput    SFVec3f    translation
  inputOutput    SFRotation rotation
  inputOutput    SFVec3f    scale
  inputOutput    MFInt32    dimension
  inputOutput    MFInt32    majorLineEvery
  inputOutput    MFInt32    majorLineOffset
  inputOutput    SFVec3f    planeOffset
  inputOutput    SFColor    planeColor
  inputOutput    SFFloat    planeTransparency
  inputOutput    SFColor    lineColor
  inputOutput    SFFloat    lineTransparency
  inputOutput    SFColor    majorLineColor
  inputOutput    SFFloat    majorLineTransparency
  inputOutput    SFVec3f    numberOffset
  inputOutput    SFNode     numberAppearance
  inputOutput    SFNode     numberFontStyle
  initializeOnly SFBool     solid
]
"Grid.x3d#Grid"

EXTERNPROTO LineTrail [
  inputOutput SFTime  resetTime
  inputOutput SFVec3f point
  inputOutput SFInt32 dimension
]
"LineTrail.x3d#LineTrail"

NavigationInfo {
  type "PLANE_create3000.de"
  transitionType "ANIMATE"
}

Viewpoint {
  description "Initial View"
  position 0 0 28.9553
}

DEF Grid Group {
  children [
    Grid {
      rotation 1 0 0 1.5707963
      dimension [ 60, 0, 30 ]
      planeOffset 0 -0.001 0
      planeColor 1 1 1
      planeTransparency 0
      lineColor 0 0 0
      majorLineColor 0 0 0
      majorLineTransparency 0.4
      numberOffset -0.1 0 0.14
      numberAppearance Appearance {
        material Material {
          diffuseColor 0 0 0
        }
      }
      numberFontStyle ScreenFontStyle {
        justify [ "END", "BEGIN" ]
      }
    }
    DEF Touch TouchSensor { }
    DEF PickingScript Script {
      inputOnly      SFTime  set_touchTime
      inputOnly      SFVec3f set_hitPoint
      inputOutput    SFInt32 pointType 0
      inputOutput    SFBool  active FALSE
      outputOnly     SFTime  doubleClickTime
      initializeOnly SFTime  doubleClickInterval 0.3
      initializeOnly SFFloat pointSize 0.5
      initializeOnly SFNode  xInterpolator DEF XInterpolator ScalarInterpolator {
        key [ 0, 0.375, 0.75, 1 ]
        keyValue [ -20, -5, 10, 20 ]
      }
      initializeOnly SFNode  yInterpolator DEF YInterpolator SplineScalarInterpolator {
        key [ -20, -5, 10, 20 ]
        keyValue [ -10, 5, -5, 10 ]
        keyVelocity [ 0, 0, 0, 0 ]
      }

      url "ecmascript:

var
	firstTime     = 0,
	pointIndex    = -1,
	hitPoint      = new SFVec2f (),
	offset        = new SFVec2f (),
	velocityScale = 0.5,
	SPLINE        = 0,
	VELOCITY      = 1;

function initialize ()
{
	xInterpolator .key         = new MFFloat (0, 0.375, 0.75, 1);
	xInterpolator .keyValue    = new MFFloat (-20, -5, 10, 20);
	yInterpolator .keyValue    = new MFFloat (-10, 5, -5, 10);
	yInterpolator .keyVelocity = new MFFloat (0, 0, 0, 0);
}

function set_touchTime (value, time)
{
	if (pointType == VELOCITY)
		return;

	if (value - firstTime > doubleClickInterval)
	{
		firstTime = value;
		return;
	}

	doubleClickTime = time;

	if (pointType == SPLINE)
	{
		if (pointIndex < 0 || pointIndex >= xInterpolator .keyValue .length)
			addPoint ();

		else
			removePoint ();
	}
}

function set_hitPoint (value, time)
{
	hitPoint .x = value .x;
	hitPoint .y = value .y;

	if (! active)
		return;

	if (pointIndex < 0 || pointIndex >= xInterpolator .keyValue .length)
		return;

	switch (pointType)
	{
		case SPLINE:
			xInterpolator .keyValue [pointIndex] = hitPoint .x + offset .x;
			yInterpolator .keyValue [pointIndex] = hitPoint .y + offset .y;
			break;
		case VELOCITY:
			yInterpolator .keyVelocity [pointIndex] = ((hitPoint .y + offset .y) - yInterpolator .keyValue [pointIndex]) / velocityScale;
			break;
	}
}

function set_active (value, time)
{
	if (! active)
		return;

	pointIndex = pick (hitPoint);
}

function pick (hitPoint)
{
	var pointIndex = -1;

	for (var i = 0, length = xInterpolator .keyValue .length; i < length; ++ i)
	{
		var yOffset = 0;
		
		if (pointType == VELOCITY)
			yOffset = yInterpolator .keyVelocity [i] * velocityScale;

		var point = new SFVec2f (xInterpolator .keyValue [i],
		                         yInterpolator .keyValue [i] + yOffset);

		offset = point .subtract (hitPoint);

		if (offset .length () > pointSize)
			continue;

		pointIndex = i;
		break;
	}
	
	return pointIndex;
}

function addPoint ()
{
	var pointIndex = getAddPointIndex ()

	xInterpolator .keyValue    .splice (pointIndex, 0, hitPoint .x);
	yInterpolator .keyValue    .splice (pointIndex, 0, hitPoint .y);
	yInterpolator .keyVelocity .splice (pointIndex, 0, 0);
	
	setXInterpolatorKey ();
}

function removePoint ()
{
	var pointIndex = getRemovePointIndex ()

	xInterpolator .keyValue    .splice (pointIndex, 1);
	yInterpolator .keyValue    .splice (pointIndex, 1);
	yInterpolator .keyVelocity .splice (pointIndex, 1);

	setXInterpolatorKey ();
}

function getAddPointIndex ()
{
	for (var i = 0, length = xInterpolator .keyValue .length; i < length; ++ i)
	{
		if (xInterpolator .keyValue [i] > hitPoint .x)
			break;
	}
	
	return i;
}

function getRemovePointIndex ()
{
	var
		first = xInterpolator .keyValue [0];
		last  = xInterpolator .keyValue [xInterpolator .keyValue .length - 1];

	if (hitPoint .x < first)
		return 0;

	if (hitPoint .x > last)
		return xInterpolator .keyValue .length - 1;

	return pick (hitPoint);
}

function setXInterpolatorKey ()
{
	if (xInterpolator .keyValue .length)
	{
		var
			first       = xInterpolator .keyValue [0];
			last        = xInterpolator .keyValue [xInterpolator .keyValue .length - 1];
			distance    = last - first,
			totalLength = 0,
			lengthSoFar = 0;

		for (var i = 1, length = xInterpolator .keyValue .length; i < length; ++ i)
		{
			var point0 = new SFVec2f (xInterpolator .keyValue [i - 1],
				                       yInterpolator .keyValue [i - 1]);
				                       
			var point1 = new SFVec2f (xInterpolator .keyValue [i],
				                       yInterpolator .keyValue [i]);
				                      
			totalLength += point1 .subtract (point0) .length ();
		}

		xInterpolator .key [0] = 0;

		for (var i = 1, length = xInterpolator .keyValue .length; i < length; ++ i)
		{
			var point0 = new SFVec2f (xInterpolator .keyValue [i - 1],
				                       yInterpolator .keyValue [i - 1]);
				                       
			var point1 = new SFVec2f (xInterpolator .keyValue [i],
				                       yInterpolator .keyValue [i]);
				                      
			lengthSoFar += point1 .subtract (point0) .length ();
			
			xInterpolator .key [i] = lengthSoFar / totalLength;
		}

		xInterpolator .key .length = length;
	}
	else
	{
		xInterpolator .key .length = 0;
	}
}
"
    }
  ]
}

DEF LineTrail Group {
  children [
    DEF Timer TimeSensor {
      cycleInterval 10
      loop TRUE
    }
    USE XInterpolator
    USE YInterpolator
    DEF TrailScript Script {
      inputOnly      SFFloat set_y
      outputOnly     SFVec3f point_changed
      initializeOnly SFNode  xInterpolator USE XInterpolator
      initializeOnly SFNode  yInterpolator USE YInterpolator

      url "ecmascript:

function set_y (value, time)
{
	point_changed .x = xInterpolator .value_changed;
	point_changed .y = yInterpolator .value_changed;
}
"
    }
    Shape {
      appearance Appearance {
        lineProperties LineProperties {
          linewidthScaleFactor 3
        }
        material Material {
          emissiveColor 0.552941 0.270588 0.14902
        }
      }
      geometry DEF Trail LineTrail {
        resetTime 1505552564.37677
        point -20 -10 0
        dimension 1000
      }
    }
  ]
}

DEF PointTypeSwitch Switch {
  whichChoice 0
  children [
    DEF Points Transform {
      children [
        DEF PointsScript Script {
          inputOnly      MFFloat set_x
          inputOnly      MFFloat set_y
          initializeOnly SFNode  points DEF _1 Polypoint2D {
            point [ -20 -10, -5 5, 10 -5, 20 10 ]
          }
          initializeOnly SFNode  xInterpolator USE XInterpolator
          initializeOnly SFNode  yInterpolator USE YInterpolator

          url "ecmascript:

function initialize ()
{
	eventsProcessed ();
}

function eventsProcessed ()
{
	for (var i = 0, length = xInterpolator .keyValue .length; i < length; ++ i)
	{
		points .point [i] .x = xInterpolator .keyValue [i];
		points .point [i] .y = yInterpolator .keyValue [i];
	}

	points .point .length = i;
}
"
        }
        Shape {
          appearance Appearance {
            lineProperties DEF _2 LineProperties {
              linewidthScaleFactor 20
            }
            material Material {
              emissiveColor 1 0.75 0.5
            }
          }
          geometry USE _1
        }
        Shape {
          appearance Appearance {
            lineProperties DEF _3 LineProperties {
              linewidthScaleFactor 8
            }
            material Material {
              emissiveColor 1 0.5 0
            }
          }
          geometry USE _1
        }
      ]
    }
    DEF KeyVelocity Transform {
      children [
        DEF KeyVelocityScript Script {
          inputOnly      MFFloat set_x
          inputOnly      MFFloat set_y
          inputOnly      MFFloat set_velocity
          initializeOnly SFNode  lines DEF _4 LineSet {
            vertexCount [ 2, 2, 2, 2 ]
            coord Coordinate {
              point [ -20 -10 0, -20 -10 0, -5 5 0, -5 5 0, 10 -5 0, 10 -5 0, 20 10 0, 20 10 0 ]
            }
          }
          initializeOnly SFNode  points DEF _5 Polypoint2D {
            point [ -20 -10, -5 5, 10 -5, 20 10 ]
          }
          initializeOnly SFNode  xInterpolator USE XInterpolator
          initializeOnly SFNode  yInterpolator USE YInterpolator

          url "ecmascript:

var velocityScale = 0.5;

function initialize ()
{
	eventsProcessed ();
}

function eventsProcessed ()
{
	for (var i = 0, length = xInterpolator .keyValue .length; i < length; ++ i)
	{
		var
			x = xInterpolator .keyValue [i],
			y = yInterpolator .keyValue [i],
			v = y + yInterpolator .keyVelocity [i] * velocityScale;

		lines .vertexCount [i] = 2;

		lines .coord .point [i * 2 + 0] .x = x;
		lines .coord .point [i * 2 + 0] .y = y;
		lines .coord .point [i * 2 + 1] .x = x;
		lines .coord .point [i * 2 + 1] .y = v;

		points .point [i] .x = x;
		points .point [i] .y = v;
	}

	lines .vertexCount .length  = i;
	lines .coord .point .length = i * 2;
	points .point .length       = i;
}
"
        }
        Shape {
          appearance Appearance {
            lineProperties LineProperties {
              linewidthScaleFactor 2
            }
            material DEF _6 Material {
              emissiveColor 0.117647 0.564706 1
            }
          }
          geometry USE _4
        }
        Shape {
          appearance Appearance {
            lineProperties USE _3
            material USE _6
          }
          geometry USE _1
        }
        Shape {
          appearance Appearance {
            lineProperties USE _2
            material Material {
              emissiveColor 0.429132 0.718372 1
            }
          }
          geometry USE _5
        }
        Shape {
          appearance Appearance {
            lineProperties USE _3
            material USE _6
          }
          geometry USE _5
        }
      ]
    }
  ]
}

ROUTE XInterpolator.value_changed TO YInterpolator.set_fraction
ROUTE Timer.fraction_changed TO XInterpolator.set_fraction
ROUTE YInterpolator.value_changed TO TrailScript.set_y
ROUTE TrailScript.point_changed TO Trail.set_point
ROUTE Timer.cycleTime TO Trail.set_resetTime
ROUTE XInterpolator.keyValue_changed TO YInterpolator.set_key
ROUTE XInterpolator.keyValue_changed TO PointsScript.set_x
ROUTE YInterpolator.keyValue_changed TO PointsScript.set_y
ROUTE Touch.isActive TO PickingScript.set_active
ROUTE Touch.hitPoint_changed TO PickingScript.set_hitPoint
ROUTE Touch.touchTime TO PickingScript.set_touchTime
ROUTE PickingScript.doubleClickTime TO Trail.set_resetTime
ROUTE PointTypeSwitch.whichChoice_changed TO PickingScript.set_pointType
ROUTE XInterpolator.keyValue_changed TO KeyVelocityScript.set_x
ROUTE YInterpolator.keyValue_changed TO KeyVelocityScript.set_y
ROUTE YInterpolator.keyVelocity_changed TO KeyVelocityScript.set_velocity
